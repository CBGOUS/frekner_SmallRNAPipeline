/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package no.uio.medisin.bag.ngssmallrna.steps;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import no.uio.medisin.bag.core.mirna.MiRNA;
import no.uio.medisin.bag.core.mirna.PreMiRNA;
import no.uio.medisin.bag.core.mirna.PreMiRNASet;
import no.uio.medisin.bag.ngssmallrna.pipeline.ReferenceDataLocations;
import no.uio.medisin.bag.ngssmallrna.pipeline.SampleDataEntry;
import static no.uio.medisin.bag.ngssmallrna.steps.NGSStep.FILESEPARATOR;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;


/**
 * 
 * Consolidate a set of results file generated by the StepParseSAMForPreMiRNAReads
 * 
 * 
 * @author sr
 */

public class StepConsolidatePreMiRNAData extends NGSStep{
    
    static Logger                   logger                          = LogManager.getLogger();
    
    public static final NGSStepSubclass STEP_SUBCLASS               = NGSStepSubclass.DATABLE;
    
    public  static final String     STEP_ID_STRING                  = "ConsolidatePreMiRNAData";
    private static final String     ID_MIRBASE_VERSION              = "mirbaseVersion";
    private static final String     ID_REF_GENOME                   = "host";
        

    private static final String     RAW_INPUT_EXTENSION             = ".fastq.gz";
    private static final String     INFILE_EXTENSION                = ".trim.clp.gen.premir_details.txt";
    private static final String     PREMIR_SUMMARY_EXTENSION        = ".fwhm.tsv";
   


    PreMiRNASet              mirBasePreMiRNASet              = new PreMiRNASet();           
    
    private int                     locationBleed                   = 2;
    private Boolean                 generateMetrics                 = false;
    private int                     miRBaseRelease                  = 20;
    private String                  referenceGenome                 = "";
    private int                     baselinePercent                 = 5;
    



    public StepConsolidatePreMiRNAData(){
        classSubtype = NGSStepSubclass.DATABLE;
    }
    
    /**
     * 
     * @param sid StepInputData
     * 
     */
    public StepConsolidatePreMiRNAData(InputDataForStep sid){
        classSubtype = NGSStepSubclass.DATABLE;
        stepInputData = sid;
    }
    
    
    
    @Override
    public String shortStepDescription(){
      return "Consolidate a set of results file generated by the StepParseSAMForPreMiRNARead step";
    }
    
    
    
    @Override
    public String longStepDescription(){
      return "Consolidate a set of results file generated by the StepParseSAMForPreMiRNARead step.\n";
    }


    @Override
    public void parseStepParameters() throws Exception{
      
    }
    
    
    
    /**
     * in this method we are simply checking that the configuration file 
     * has all the entries we need. We dont check if the values are acceptable
     * that is the role of the NGSStep.
     * 
     * @param configData
     * @throws Exception 
     */
    @Override
    public void parseConfigurationData(HashMap configData) throws Exception{
        logger.info(STEP_ID_STRING + ": verify configuration data");
        
        if(configData.get(ID_MIRBASE_VERSION)==null) {
            logger.error("<" + ID_MIRBASE_VERSION + "> : Missing Definition in Configuration File");
            throw new NullPointerException("<" + ID_MIRBASE_VERSION + "> : Missing Definition in Configuration File");
        }
        if(configData.get(ID_REF_GENOME)==null) {
            logger.error("<" + ID_REF_GENOME + "> : Missing Definition in Configuration File");
            throw new NullPointerException("<" + ID_REF_GENOME + "> : Missing Definition in Configuration File");
        }
        

        String chk;
        chk = checkParameter("Integer", ID_MIRBASE_VERSION, Integer.toString((Integer)configData.get(ID_MIRBASE_VERSION)), "0", "NA", logger);
        if(chk!=null)
            this.setMiRBaseRelease((Integer) configData.get(ID_MIRBASE_VERSION));

        

        this.setReferenceGenome((String) configData.get(ID_REF_GENOME));
        if(this.getReferenceGenome().length() !=3 ){
            logger.error(ID_REF_GENOME + " <" + configData.get(ID_REF_GENOME) + "> must be a 3 letter string");            
            throw new IllegalArgumentException(ID_REF_GENOME + " <" + configData.get(ID_REF_GENOME) + "> must be a 3 letter string");            
        }

        

        logger.info("passed");
    }
    
    
    
    /**
     * count up reads that overlap features specified in the GFF file
     * 
     * @throws IOException 
     */
    @Override
    public void execute()  throws IOException{
        
        logger.info(STEP_ID_STRING + ": execute");                
    
        String miRBaseGFFFile = this.cleanPath(getStepInputData().getDataLocations().getMirbaseFolder() 
                + FILESEPARATOR + this.getMiRBaseRelease() + FILESEPARATOR + this.getReferenceGenome() + ".gff3");
        
        Boolean fA = new File(outFolder).mkdir();       
        if (fA) logger.info("created output folder <" + outFolder + "> for results" );
        String preMiRLine = null;
        String preMiRNAResultInputFile = "";

        PreMiRNASet mirGeneDBList = new PreMiRNASet();
        String mirgdbLine = "";
        String mirGeneDBFile = this.cleanPath(getStepInputData().getDataLocations().getMirgenedbfolder()
            + FILESEPARATOR + this.getReferenceGenome() + ".mirgenedb.tsv");
        try{
        BufferedReader brMG = new BufferedReader(new FileReader(new File(mirGeneDBFile)));
            brMG.readLine(); // header line
            while((mirgdbLine=brMG.readLine())!=null){
                PreMiRNA preMiRNA = new PreMiRNA();
                preMiRNA.parseMirGeneDBEntry(mirgdbLine);
                mirGeneDBList.addPriMiRNA(preMiRNA);
            }
        brMG.close();
        }
        catch(IOException exIO){
            logger.info("Exception parsing MirGeneDB file <" + mirGeneDBFile  + ">");
            logger.info(exIO);
            throw new IOException("Exception parsing MirGeneDB file <" + mirGeneDBFile  + ">");
        }

        // dont think we need this, but keep the path for now
        String genomeFastaFile = this.cleanPath(
                getStepInputData().getDataLocations().getGenomeRootFolder()
                        + FILESEPARATOR + this.getReferenceGenome() 
                        + FILESEPARATOR + ReferenceDataLocations.ID_REL_WHOLE_GENSEQ_PATH 
                        + FILESEPARATOR + "genome.fa");
        
        genomeFastaFile = null;

        mirBasePreMiRNASet.loadMiRBaseData(this.getReferenceGenome(), miRBaseGFFFile, genomeFastaFile);
        
        /*
            match the miRBase entry to the miRGeneDB entry
            preMiRNAResults is a list by miRNAs, since we are lo
        */
        String noteTitle = summarizeNoteHeader()
                + "pre-miRNA Name|pre-miRNA MIMAID|"
                + "miRNA A name|miRNA A MIMATID|miRGeneDB Name A|miRGeneDB Gene Node A|"
                + "miRNA B name|miRNA B MIMATID|miRGeneDB Name B|miRGeneDB Gene Node B|\t";


        for(PreMiRNA preMiRNA: mirBasePreMiRNASet.getPreMiRNAList()){
            logger.info(preMiRNA.getName() + "|" + preMiRNA.getMiID());
            preMiRNA.setNote(preMiRNA.getName() + "|" + preMiRNA.getMiID() + "|");

            MiRNA miRNA = preMiRNA.getMiRNAList().get(0);
            String miRNAAString = miRNA.getName() + "|" + miRNA.getMimatID() + "|";
            PreMiRNA mirGeneDBHit = mirGeneDBList.doesListContainMiRNA(miRNA.getMimatID());
            if(mirGeneDBHit!=null){                    
                miRNAAString = miRNAAString.concat(mirGeneDBHit.getMirGeneDBGeneName() 
                        + "|" + mirGeneDBHit.getMirGeneDBNodeOfOriginGene() + "|");                    
            } 
            else
                miRNAAString = miRNAAString.concat(" | |");
            
            String miRNABString = miRNA.getName() + "|" + miRNA.getMimatID() + "|";

            if(preMiRNA.getMiRNAList().size()>1)
            {
                miRNA = preMiRNA.getMiRNAList().get(1);
                mirGeneDBHit = mirGeneDBList.doesListContainMiRNA(miRNA.getMimatID());
                if(mirGeneDBHit!=null){                    
                    miRNABString = miRNABString.concat(mirGeneDBHit.getMirGeneDBGeneName() 
                            + "|" + mirGeneDBHit.getMirGeneDBNodeOfOriginGene());                    
                } 
                else
                    miRNABString = miRNABString.concat(" |");
                
            }
            else{
                miRNABString = " | | |";
            }
            preMiRNA.appendNote(miRNAAString + miRNABString + "\t");


        }
        
        /**
         * main processing loop
         */
        
        Iterator itSD = this.getStepInputData().getSampleData().iterator();
        while (itSD.hasNext()){
            try{
                
                /**
                 * we may be merging results from different projects, so we have to
                 * reset the project path for each sample
                 */
                SampleDataEntry sampleData = (SampleDataEntry)itSD.next();
                String projectFolder = getStepInputData().getProjectRoot() + FILESEPARATOR + sampleData.getNote();
                projectFolder = projectFolder.replace(FILESEPARATOR + FILESEPARATOR, FILESEPARATOR).trim();
                inFolder = projectFolder + FILESEPARATOR + getStepInputData().getInputFolder();

                preMiRNAResultInputFile = this.cleanPath(inFolder + FILESEPARATOR + sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, INFILE_EXTENSION));
                logger.info(sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, INFILE_EXTENSION));
                preMiRLine = null;
                BufferedReader brPre = new BufferedReader(new FileReader(new File(preMiRNAResultInputFile)));

                ArrayList<String> preMiRNALines = new ArrayList<>();
                preMiRLine=brPre.readLine();
                noteTitle = noteTitle.concat(
                        sampleData.getNote().trim() 
                        + "|" + sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, "").trim() + "|"
                        + "FWHM_UpperStartPos|" + "\t"
                        + sampleData.getNote().trim()
                        + "|" + sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, "").trim() + "|"
                        + "FWHM_UpperReadLen|" + "\t"
                        + sampleData.getNote().trim()
                        + "|" + sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, "").trim() + "|"
                        + "FWHM_LowerStartPos|" + "\t"
                        + sampleData.getNote().trim()
                        + "|" + sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, "").trim() + "|"
                        + "FWHM_LowerReadLen|" + "\t");
                do{
                    if(preMiRLine==null)
                        break;
                    
                    if(preMiRLine.equals(StepParseSAMForPreMiRNAReads.PREMIRNA_START_ENTRY)== false){
                        preMiRLine=brPre.readLine();
                        continue;
                    }
                    
                    while((preMiRLine=brPre.readLine()).equals(StepParseSAMForPreMiRNAReads.PREMIRNA_END_ENTRY)==false){
                        preMiRNALines.add(preMiRLine);
                    }
                    String fwhmString = this.parseFWHMValuesFromPreMiRNALines(preMiRNALines);
                    logger.debug(fwhmString);
                    String note = mirBasePreMiRNASet.getPreMiRNAList().get(
                            mirBasePreMiRNASet.findEntryIndexByMiID(
                                    fwhmString.split("\\|")[0].trim())).appendNote(fwhmString.split("\\|")[1].trim() + "\t");
                    
                    preMiRLine=brPre.readLine();
                }while(true);


                brPre.close();
                logger.info("  completed processing SAM file\n\n");
                
                
            }
            catch(IOException ex){
                logger.error("error processing sample <" + preMiRNAResultInputFile + ">\n" + ex.toString());
                throw new IOException(STEP_ID_STRING + ": error processing sample <" + preMiRNAResultInputFile + ">");
            }
            catch(ArrayIndexOutOfBoundsException exBnd){
                logger.error("error parsing line " + preMiRLine);
                logger.error(exBnd);
                throw new IOException(STEP_ID_STRING + ": error processing sample <" + preMiRNAResultInputFile + ">: line was \n" + preMiRLine);
            }
        }
        

            
        String fwhmFile   = outFolder + FILESEPARATOR + getStepInputData().getProjectID() + PREMIR_SUMMARY_EXTENSION;
        //String summaryFile      = outFolder + FILESEPARATOR + getStepInputData().getProjectID() + ".disp.summary.tsv";
        logger.info("write dispersions to file <" + fwhmFile + ">");
        try{
            BufferedWriter bwFW = new BufferedWriter(new FileWriter(new File(fwhmFile)));
            bwFW.write(noteTitle + "\n");
            for(PreMiRNA preMiRNA: mirBasePreMiRNASet.getPreMiRNAList()){ 
                logger.debug(preMiRNA.getName());
                logger.debug(preMiRNA.getNote());
                        
                bwFW.write(this.summarizePreMiRNANote(preMiRNA.getNote()) + preMiRNA.getNote() + "\n");
                
            }
            bwFW.close();
        }
        catch(IOException exIO){
            logger.info("error writing isomiR dispersion File <" + fwhmFile + ">\n" + exIO);
            throw new IOException(STEP_ID_STRING + "error writing isomiR dispersion File <" + fwhmFile + ">");
        }
           
        
        logger.info(STEP_ID_STRING + ": completed");
        
        
    }
    
    
    /**
     * parse out a set of lines corresponding to an pre-miRNA result entry
     * generated as output from the @see no.uio.medisin.bag.ngssmallrna.steps.StepParseSAMForPreMiRNAReads class
     * the method will return the FWHM values for the start position and read length distributions
     * 
     * @param preMiRNAlines
     * @return tab delimited string for FWHM values for the start position and read length distributions
     */
    private String parseFWHMValuesFromPreMiRNALines(ArrayList<String> preMiRlines){
        String mimaID = "";
        String fwhmStartString = "";
        String fwhmLengthString = "";
        String fwhmUpperStartString = "";
        String fwhmUpperLengthString = "";
        String fwhmLowerStartString = "";
        String fwhmLowerLengthString = "";
        for(String preMiRLine: preMiRlines){
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_NAME_SECTION)){
                mimaID = preMiRLine.split(":")[1].trim().split("\\|")[0].trim();
            }
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_LEN_FWHM)){
                fwhmStartString = preMiRLine.split(":")[1].trim();
            }
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_START_FWHM)){
                fwhmLengthString = preMiRLine.split(":")[1].trim();                
            }
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_UPPERLEN_FWHM)){
                fwhmUpperStartString = preMiRLine.split(":")[1].trim();
            }
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_UPPERSTART_FWHM)){
                fwhmUpperLengthString = preMiRLine.split(":")[1].trim();                
            }
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_LOWERLEN_FWHM)){
                fwhmLowerStartString = preMiRLine.split(":")[1].trim();
            }
            if(preMiRLine.startsWith(StepParseSAMForPreMiRNAReads.PREMIRNA_LOWERSTART_FWHM)){
                fwhmLowerLengthString = preMiRLine.split(":")[1].trim();                
            }
        }
        
        /*
        if we are here, we should have both values for the FWHM upper and lower arm 
        */
        return mimaID + "|" + fwhmUpperStartString + "\t" + fwhmUpperLengthString + "\t" 
                + fwhmLowerStartString + "\t" + fwhmLowerLengthString;
    }
    
    
    
    
    private String summarizeNoteHeader(){
        return 
                   "preMiRID" + "\t"
                + "miRNameA" + "\t"
                + "miRGeneIDA" + "\t"
                + "miRNameB" + "\t"
                + "miRGeneIDB" + "\t"
                + "UpStMn" + "\t"
                + "UpLnMn" + "\t"
                + "LwStMn" + "\t"
                + "LwLnMn" + "\t"
                + "UpStSD" + "\t"
                + "UpLnSD" + "\t"
                + "LwStSD" + "\t"
                + "LwLnSD" + "\t";
    }
    
    
    /**
     * generate some summary statistics about the data stored in the note
     * 
     * @param note
     * @return 
     */
    private String summarizePreMiRNANote(String note){
        String cols[] = note.split("\t");
        
        String preMiRNAString = cols[0].trim();
        logger.debug(preMiRNAString);
        logger.debug(preMiRNAString.split("\\|").length);
        String preMiRID = preMiRNAString.split("\\|")[1].trim();
        logger.debug(preMiRID);
        String miRNameA = preMiRNAString.split("\\|")[2].trim();
        logger.debug(miRNameA);
        String miRGeneIDA = preMiRNAString.split("\\|")[4].trim();
        logger.debug(miRGeneIDA);
        String miRNameB = preMiRNAString.split("\\|")[6].trim();
        logger.debug(miRNameB);
        String miRGeneIDB = preMiRNAString.split("\\|")[8].trim();
        logger.debug(miRGeneIDB);
        

        if(miRGeneIDA.isEmpty())
            miRGeneIDA="F";
        else
            miRGeneIDA="T";

        if(miRGeneIDB.isEmpty())
            miRGeneIDB="F";
        else
            miRGeneIDB="T";
        
        DescriptiveStatistics upperStartStats   = new DescriptiveStatistics();
        DescriptiveStatistics lowerStartStats   = new DescriptiveStatistics();
        DescriptiveStatistics upperLenStats     = new DescriptiveStatistics();
        DescriptiveStatistics lowerLenStats     = new DescriptiveStatistics();

        
        
        
        int c = 0;
        do{
            upperStartStats.addValue(Double.valueOf(cols[1+c*4].trim()));
            lowerStartStats.addValue(Double.valueOf(cols[1+c*4+1].trim()));
            upperLenStats.addValue(Double.valueOf(cols[1+c*4+2].trim()));
            lowerLenStats.addValue(Double.valueOf(cols[1+c*4+3].trim()));
            c++;
        }while(1+c*4<cols.length);
        
        return  
                preMiRID + "\t"
                + miRNameA + "\t"
                + miRGeneIDA + "\t"
                + miRNameB + "\t"
                + miRGeneIDB + "\t"
                + upperStartStats.getMean() + "\t"
                + upperLenStats.getMean() + "\t"
                + lowerStartStats.getMean() + "\t"
                + lowerLenStats.getMean() + "\t"
                + upperStartStats.getStandardDeviation() + "\t"
                + upperLenStats.getStandardDeviation() + "\t"
                + lowerStartStats.getStandardDeviation() + "\t"
                + lowerLenStats.getStandardDeviation() + "\t";

                }
    
    /**
     * Verify Input Data for parsing SAM file for miRNAs
     * @throws IOException
     */        
    @Override
    public void verifyInputData() throws IOException{
        
        logger.info("verify input data");        
        this.setPaths();
        String gffFileMirBase = this.cleanPath(getStepInputData().getDataLocations().getMirbaseFolder() 
                + FILESEPARATOR + this.getMiRBaseRelease() + FILESEPARATOR + this.getReferenceGenome() + ".gff3");
        
        if (new File(gffFileMirBase).exists()==false){
            logger.error("no annotation file was found for mirBase HOST:<" 
                    + this.getReferenceGenome() + "> VERSION: <"+ this.getMiRBaseRelease() + "> at location <" 
                    + gffFileMirBase + ">");
            throw new IOException("no annotation file was found for mirBase HOST:<" 
                    + this.getReferenceGenome() + "> VERSION: <"+ this.getMiRBaseRelease() + "> at location <" 
                    + gffFileMirBase + ">");
        }
                
        // check the pre-miRNA result files exist
        Iterator itSD = this.getStepInputData().getSampleData().iterator();
        while (itSD.hasNext()){
            SampleDataEntry sampleData = (SampleDataEntry)itSD.next();
            String projectFolder = getStepInputData().getProjectRoot() + FILESEPARATOR + sampleData.getNote();
            projectFolder = projectFolder.replace(FILESEPARATOR + FILESEPARATOR, FILESEPARATOR).trim();
            inFolder = projectFolder + FILESEPARATOR + getStepInputData().getInputFolder();
            
            if (sampleData.getFastqFile1()==null) throw new IOException("no Fastq1 file specified");
            String preMiRNAResultFile = inFolder + FILESEPARATOR + sampleData.getFastqFile1().replace(RAW_INPUT_EXTENSION, INFILE_EXTENSION);            

            if ((new File(preMiRNAResultFile)).exists()==false){
                throw new IOException(STEP_ID_STRING + ": pre-miRNA result file <" + preMiRNAResultFile + "> does not exist");
            }
            if (preMiRNAResultFile.toUpperCase().endsWith(INFILE_EXTENSION.toUpperCase())==false)
            {
                throw new IOException(STEP_ID_STRING + ": incorrect file extension for input file <" 
                  + preMiRNAResultFile + ">.  \n" 
                  + "should have <" + INFILE_EXTENSION + "> as extension");
            }
            
        }

    }
    
    
    
    
    /**
     * generate sample configuration data so the user can see what can be
     * specified
     *
     * @return
     */
    @Override
    public HashMap generateExampleConfigurationData() {

        logger.info(STEP_ID_STRING + ": generate example configuration data");

        HashMap configData = new HashMap();

        configData.put(ID_REF_GENOME, "hsa");
        configData.put(ID_MIRBASE_VERSION, 20);

        return configData;
        
    }





    @Override
    public void verifyOutputData(){
        
    }

    
 
    @Override
    public NGSStepSubclass getStepSubclass(){
        return STEP_SUBCLASS;
    }
    
    
    
    
    /**
     * @return the locationBleed
     */
    public int getLocationBleed() {
        return locationBleed;
    }

    /**
     * @param locationBleed the locationBleed to set
     */
    public void setLocationBleed(int locationBleed) {
        this.locationBleed = locationBleed;
    }

    /**
     * @return the analyzeIsomirs
     */
    public Boolean getAnalyzeIsomirs() {
        return generateMetrics;
    }

    /**
     * @param analyzeIsomirs the analyzeIsomirs to set
     */
    public void setAnalyzeIsomirs(Boolean analyzeIsomirs) {
        this.generateMetrics = analyzeIsomirs;
    }

    /**
     * @return the miRBaseRelease
     */
    public int getMiRBaseRelease() {
        return miRBaseRelease;
    }

    /**
     * @param miRBaseRelease the miRBaseRelease to set
     */
    public void setMiRBaseRelease(int miRBaseRelease) {
        this.miRBaseRelease = miRBaseRelease;
    }

    /**
     * @return the ReferenceGenome
     */
    public String getReferenceGenome() {
        return referenceGenome;
    }

    /**
     * @param ReferenceGenome the ReferenceGenome to set
     */
    public void setReferenceGenome(String ReferenceGenome) {
        this.referenceGenome = ReferenceGenome;
    }

    /**
     * @return the baselinePercent
     */
    public int getBaselinePercent() {
        return baselinePercent;
    }

    /**
     * @param baselinePercent the baselinePercent to set
     */
    public void setBaselinePercent(int baselinePercent) {
        this.baselinePercent = baselinePercent;
    }

}
